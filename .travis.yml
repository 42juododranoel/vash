language: bash


addons:
  apt:
    packages:
      - sshpass
      - docker-ce


before_install:
  - # Shortcuts to interact with production

  - alias run_on_production='sshpass -e ssh ${PRODUCTION_SERVER_USERNAME}@${PRODUCTION_SERVER_HOST}'
  - shopt -s expand_aliases
  - ssh-keyscan -t rsa ${PRODUCTION_SERVER_HOST} > ~/.ssh/known_hosts

  - >
    function send_to_production {
      source=$1
      destination=$2
      sshpass \
        -e scp \
        ${source} \
        ${PRODUCTION_SERVER_USERNAME}@${PRODUCTION_SERVER_HOST}:${destination}
    }

  - >
    function download_from_production {
      source=$1
      destination=$2
      sshpass \
        -e scp \
        ${PRODUCTION_SERVER_USERNAME}@${PRODUCTION_SERVER_HOST}:${source} \
        ${destination}
    }


  - # Common environment variables

  - export PROJECT_NAME='vash'
  - export PROJECT_URL='https://github.com/vsevolod-skripnik/vash.git'
  - export USER=`whoami`
  - export COMMIT=`echo ${TRAVIS_COMMIT:0:7}`  # Shorten commit hash

  - export SSHPASS=${PRODUCTION_SERVER_PASSWORD}
  - export PRODUCTION_USER=`(run_on_production 'id -u')`
  - export HOST_USER_ID=${PRODUCTION_USER}

  - export POSTGRES_BACKUP_NAME='backup.sql'
  - export POSTGRES_BACKUP_PATH="/tmp/${POSTGRES_BACKUP_NAME}"
  - export POSTGRES_ARTEFACT_NAME=`date +%d-%m-%y__%H-%M.sql`
  - export POSTGRES_ARTEFACT_PATH="/tmp/${POSTGRES_ARTEFACT_NAME}"
  - export POSTGRES_USERNAME='vash'
  - export POSTGRES_DATABASE='vash'
  - export POSTGRES_CONTAINER_NAME='vash_postgres_1'

  - export STATIC_TARBALL_NAME=${COMMIT}.tar.gz


  - # Directories

  - export MEDIA_DIRECTORY=${TRAVIS_BUILD_DIR}/resources/media
  - export STATIC_DIRECTORY=${TRAVIS_BUILD_DIR}/resources/static
  - export CERTBOT_DIRECTORY=${TRAVIS_BUILD_DIR}/resources/certbot


  - # Docker image names

  - export DOCKER_NGINX_IMAGE="vash_nginx:${COMMIT}"
  - export DOCKER_NGINX_IMAGE_FILE="${COMMIT}.tar"

  - export DOCKER_DJANGO_IMAGE="vash_django:${COMMIT}"
  - export DOCKER_DJANGO_IMAGE_FILE="${COMMIT}.tar"

  - docker_postgres_image_line=`cat .env | grep DOCKER_POSTGRES_IMAGE`
  - export DOCKER_POSTGRES_IMAGE="${docker_postgres_image_line/DOCKER_POSTGRES_IMAGE=/}"
  - export DOCKER_POSTGRES_IMAGE_FILE="${DOCKER_POSTGRES_IMAGE/:/_}.tar"


  - # Production directory structure

  - export PRODUCTION_ARTEFACTS_ROOT='~/artefacts'
  - export PRODUCTION_ARTEFACTS_DIRECTORY="${PRODUCTION_ARTEFACTS_ROOT}/${PROJECT_NAME}"
  - export PRODUCTION_ARTEFACTS_STATIC_DIRECTORY="${PRODUCTION_ARTEFACTS_DIRECTORY}/static"
  - export PRODUCTION_ARTEFACTS_POSTGRES_DIRECTORY="${PRODUCTION_ARTEFACTS_DIRECTORY}/database"

  - export PRODUCTION_BACKUPS_ROOT='~/backups'
  - export PRODUCTION_BACKUPS_DIRECTORY="${PRODUCTION_BACKUPS_ROOT}/${PROJECT_NAME}"
  - export PRODUCTION_BACKUPS_POSTGRES_DIRECTORY="${PRODUCTION_BACKUPS_DIRECTORY}/database"

  - export PRODUCTION_IMAGES_ROOT='~/images'
  - export PRODUCTION_IMAGES_DIRECTORY="${PRODUCTION_IMAGES_ROOT}/${PROJECT_NAME}"
  - export PRODUCTION_IMAGES_NGINX_DIRECTORY="${PRODUCTION_IMAGES_DIRECTORY}/nginx"
  - export PRODUCTION_IMAGES_DJANGO_DIRECTORY="${PRODUCTION_IMAGES_DIRECTORY}/django"
  - export PRODUCTION_IMAGES_POSTGRES_DIRECTORY="${PRODUCTION_IMAGES_DIRECTORY}/postgres"

  - export PRODUCTION_REPOSITORIES_ROOT='~/repositories'
  - export PRODUCTION_REPOSITORIES_DIRECTORY="${PRODUCTION_REPOSITORIES_ROOT}/${PROJECT_NAME}"

  - export PRODUCTION_RESOURCES_ROOT='~/resources'
  - export PRODUCTION_RESOURCES_DIRECTORY="${PRODUCTION_RESOURCES_ROOT}/${PROJECT_NAME}"
  - export PRODUCTION_RESOURCES_MEDIA_DIRECTORY="${PRODUCTION_RESOURCES_DIRECTORY}/media"
  - export PRODUCTION_RESOURCES_CERTBOT_DIRECTORY="${PRODUCTION_RESOURCES_DIRECTORY}/certbot"

  - export PRODUCTION_ENVIRONMENT_ROOT='~/environment'


  - # Production environment to run project

  - export PRODUCTION_STATIC_DIRECTORY=${PRODUCTION_ARTEFACTS_STATIC_DIRECTORY}/${COMMIT}
  - export PRODUCTION_REPOSITORY_DIRECTORY=${PRODUCTION_REPOSITORIES_DIRECTORY}/${COMMIT}
  - export PRODUCTION_ENVIRONMENT_FILE=${PRODUCTION_ENVIRONMENT_ROOT}/${PROJECT_NAME}.env

  - >
    if run_on_production "stat ${PRODUCTION_ENVIRONMENT_FILE} > /dev/null 2>&1";
    then
      nginx_ports_set_current=`run_on_production "cat ${PRODUCTION_ENVIRONMENT_FILE}" | grep NGINX_PORT_SET_CURRENT`;
      nginx_ports_set_previous=`run_on_production "cat ${PRODUCTION_ENVIRONMENT_FILE}" | grep NGINX_PORT_SET_PREVIOUS`;
      commit_current=`run_on_production "cat ${PRODUCTION_ENVIRONMENT_FILE}" | grep COMMIT_CURRENT`;
      commit_previous=`run_on_production "cat ${PRODUCTION_ENVIRONMENT_FILE}" | grep COMMIT_PREVIOUS`;
      export PRODUCTION_NGINX_PORT_SET_CURRENT="${nginx_ports_set_current/NGINX_PORT_SET_CURRENT=/}";
      export PRODUCTION_NGINX_PORT_SET_PREVIOUS="${nginx_ports_set_previous/NGINX_PORT_SET_PREVIOUS=/}";
      export PRODUCTION_COMMIT_CURRENT="${commit_current/COMMIT_CURRENT=/}";
      export PRODUCTION_COMMIT_PREVIOUS="${commit_previous/COMMIT_PREVIOUS=/}";
    else
      export PRODUCTION_NGINX_PORT_SET_CURRENT='A';
      export PRODUCTION_NGINX_PORT_SET_PREVIOUS='B';
      export PRODUCTION_COMMIT_CURRENT=;
      export PRODUCTION_COMMIT_PREVIOUS=;
    fi


  - # Production Postgres

  - export PRODUCTION_POSTGRES_USERNAME='vash'
  - export PRODUCTION_POSTGRES_DATABASE='vash'
  - export PRODUCTION_POSTGRES_BACKUP_NAME=`date +%d-%m-%y__%H-%M.sql`
  - export PRODUCTION_POSTGRES_BACKUP_PATH="${PRODUCTION_BACKUPS_POSTGRES_DIRECTORY}/${PRODUCTION_POSTGRES_BACKUP_NAME}"
  - export PRODUCTION_POSTGRES_ARTEFACT_NAME=${POSTGRES_ARTEFACT_NAME}
  - export PRODUCTION_POSTGRES_ARTEFACT_PATH="${PRODUCTION_ARTEFACTS_POSTGRES_DIRECTORY}/${PRODUCTION_POSTGRES_ARTEFACT_NAME}"
  - export PRODUCTION_POSTGRES_CONTAINER_NAME="${PROJECT_NAME}${COMMIT}_postgres_1"

  - # Create directory structure on production

  - >
    run_on_production "
      mkdir -p ${PRODUCTION_ENVIRONMENT_ROOT}

      mkdir -p ${PRODUCTION_ARTEFACTS_ROOT} \
               ${PRODUCTION_ARTEFACTS_DIRECTORY} \
               ${PRODUCTION_ARTEFACTS_STATIC_DIRECTORY} \
               ${PRODUCTION_ARTEFACTS_POSTGRES_DIRECTORY}

      mkdir -p ${PRODUCTION_BACKUPS_ROOT} \
               ${PRODUCTION_BACKUPS_DIRECTORY} \
               ${PRODUCTION_BACKUPS_POSTGRES_DIRECTORY} \

      mkdir -p ${PRODUCTION_IMAGES_ROOT} \
               ${PRODUCTION_IMAGES_DIRECTORY} \
               ${PRODUCTION_IMAGES_NGINX_DIRECTORY} \
               ${PRODUCTION_IMAGES_DJANGO_DIRECTORY} \
               ${PRODUCTION_IMAGES_POSTGRES_DIRECTORY}

      mkdir -p ${PRODUCTION_REPOSITORIES_ROOT} \
               ${PRODUCTION_REPOSITORIES_DIRECTORY}

      mkdir -p ${PRODUCTION_RESOURCES_ROOT} \
               ${PRODUCTION_RESOURCES_DIRECTORY} \
               ${PRODUCTION_RESOURCES_MEDIA_DIRECTORY} \
               ${PRODUCTION_RESOURCES_CERTBOT_DIRECTORY}
    "


  - # Download database backup from production

  - >
    if [ -n "${PRODUCTION_COMMIT_CURRENT}" ];
    then
      run_on_production "
        docker exec ${PROJECT_NAME}${PRODUCTION_COMMIT_CURRENT}_postgres_1 \
          pg_dump \
            -U ${PRODUCTION_POSTGRES_USERNAME} \
            ${PRODUCTION_POSTGRES_DATABASE} \
        > ${PRODUCTION_POSTGRES_BACKUP_PATH}
      "
      download_from_production ${PRODUCTION_POSTGRES_BACKUP_PATH} ${POSTGRES_BACKUP_PATH}
    else
      echo "Can't load Postgres backup because production commit is missing"
    fi


  - # Manage permissions

  - sudo chown -R ${PRODUCTION_USER}:${USER} .  # Stage and production user ids differ


  - # Build and run

  - >
    docker-compose \
      -f compose/nginx.yml \
      -f compose/django.yml \
      -f compose/postgres.yml \
      -f compose/production.yml \
      -f compose/nginx_ports_default.yml \
      --project-directory . \
      up \
      -d \
      --build

  - sleep 5s  # Give Postgres some time to boot

  - >
    while [ "$( docker exec vash_postgres_1 psql -U vash -tAc "SELECT 1 FROM pg_database WHERE datname='${POSTGRES_DATABASE}'" )" != '1' ];
    do echo 'Waiting for Postgres to create a database.'; sleep 5s; done

  - sleep 5s  # Give Postgres some time to restart after creating a database

  - >
    until [[ "$( docker exec vash_postgres_1 pg_isready )" ]];
    do echo 'Waiting for Postgres to get ready.'; sleep 5s; done


  - # Load backup into database and migrate

  - >
    if [ -n "${PRODUCTION_COMMIT_CURRENT}" ];
    then
      docker cp ${POSTGRES_BACKUP_PATH} vash_postgres_1:/tmp;
      docker exec vash_postgres_1 bash -c "psql -U ${POSTGRES_USER} ${POSTGRES_DATABASE} < /tmp/${POSTGRES_BACKUP_NAME}" > /dev/null
    fi
  - docker exec vash_django_1 python manage.py migrate --noinput


  - # Collect static

  - sudo chown -R ${PRODUCTION_USER}:${USER} ${STATIC_DIRECTORY}
  - docker exec vash_django_1 python manage.py collectstatic --noinput


  - # Upload Docker images to production

  - docker_nginx_image_path="/tmp/${DOCKER_NGINX_IMAGE_FILE}"
  - docker save -o ${docker_nginx_image_path} ${DOCKER_NGINX_IMAGE}
  - echo 'Sending Nginx image to production...'
  - send_to_production ${docker_nginx_image_path} ${PRODUCTION_IMAGES_NGINX_DIRECTORY}
  - run_on_production "docker load < ${PRODUCTION_IMAGES_NGINX_DIRECTORY}/${DOCKER_NGINX_IMAGE_FILE}"

  - docker_django_image_path="/tmp/${DOCKER_DJANGO_IMAGE_FILE}"
  - docker save -o ${docker_django_image_path} ${DOCKER_DJANGO_IMAGE}
  - echo 'Sending Django image to production...'
  - send_to_production ${docker_django_image_path} ${PRODUCTION_IMAGES_DJANGO_DIRECTORY}
  - run_on_production "docker load < ${PRODUCTION_IMAGES_DJANGO_DIRECTORY}/${DOCKER_DJANGO_IMAGE_FILE}"

  - docker_postgres_image_path="/tmp/${DOCKER_POSTGRES_IMAGE_FILE}"
  - docker save -o ${docker_postgres_image_path} ${DOCKER_POSTGRES_IMAGE}
  - echo 'Sending Postgres image to production...'
  - send_to_production ${docker_postgres_image_path} ${PRODUCTION_IMAGES_POSTGRES_DIRECTORY}
  - run_on_production "docker load < ${PRODUCTION_IMAGES_POSTGRES_DIRECTORY}/${DOCKER_POSTGRES_IMAGE_FILE}"


  - # Send static to production

  - cd ${STATIC_DIRECTORY}
  - tar -zcf /tmp/${STATIC_TARBALL_NAME} .
  - cd -
  - send_to_production /tmp/${STATIC_TARBALL_NAME} /tmp/
  - >
    run_on_production "
      mkdir -p ${PRODUCTION_STATIC_DIRECTORY}
      tar -zxf /tmp/${STATIC_TARBALL_NAME} -C ${PRODUCTION_STATIC_DIRECTORY}
    "


  - # Send database to production

  - docker exec ${POSTGRES_CONTAINER_NAME} pg_dump -U ${POSTGRES_USERNAME} ${POSTGRES_DATABASE} > ${POSTGRES_ARTEFACT_PATH}
  - send_to_production ${POSTGRES_ARTEFACT_PATH} ${PRODUCTION_ARTEFACTS_POSTGRES_DIRECTORY}


  - # Clone project to another place to run second compose on production

  - >
    run_on_production "
      cd ${PRODUCTION_REPOSITORIES_DIRECTORY}
      git clone ${PROJECT_URL} ${COMMIT}
      cd ${PRODUCTION_REPOSITORY_DIRECTORY}
      git checkout ${COMMIT}
      git reset --hard
    "


install:
  - # Run compose on production

  - >
    run_on_production "
      export DOCKER_NGINX_IMAGE=${DOCKER_NGINX_IMAGE}
      export DOCKER_DJANGO_IMAGE=${DOCKER_DJANGO_IMAGE}
      export DOCKER_POSTGRES_IMAGE=${DOCKER_POSTGRES_IMAGE}

      export DJANGO_SECRET_KEY='${DJANGO_SECRET_KEY}'
      export DJANGO_DEBUG=False

      export HOST_USER_ID=${HOST_USER_ID}

      export MEDIA_DIRECTORY=${PRODUCTION_RESOURCES_MEDIA_DIRECTORY}
      export STATIC_DIRECTORY=${PRODUCTION_STATIC_DIRECTORY}
      export CERTBOT_DIRECTORY=${PRODUCTION_RESOURCES_CERTBOT_DIRECTORY}

      cd ${PRODUCTION_REPOSITORY_DIRECTORY}
      docker-compose \
        -f compose/nginx.yml \
        -f compose/django.yml \
        -f compose/postgres.yml \
        -f compose/production.yml \
        -f compose/nginx_ports_${PRODUCTION_NGINX_PORT_SET_PREVIOUS}.yml \
        --project-directory . \
        --project-name ${PROJECT_NAME}${COMMIT} \
        up \
        -d
    "


  - # On production wait for Postgres and load artefact into it

  - >
    run_on_production "
      sleep 5s  # Give Postgres some time to boot

      while [ \"\$( docker exec ${PRODUCTION_POSTGRES_CONTAINER_NAME} psql -U ${PRODUCTION_POSTGRES_USERNAME} -tAc \"SELECT 1 FROM pg_database WHERE datname='${PRODUCTION_POSTGRES_DATABASE}'\" )\" != '1' ]; do
        echo 'Waiting for Postgres to create a database.';
        sleep 5s;
      done

      sleep 5s  # Give Postgres some time to restart after creating a database

      until [[ \"\$( docker exec ${PRODUCTION_POSTGRES_CONTAINER_NAME} pg_isready )\" ]]; do
        echo 'Waiting for Postgres to get ready.';
        sleep 5s;
      done

      docker cp ${PRODUCTION_POSTGRES_ARTEFACT_PATH} ${PRODUCTION_POSTGRES_CONTAINER_NAME}:/tmp
      docker exec ${PRODUCTION_POSTGRES_CONTAINER_NAME} bash -c 'psql -U ${PRODUCTION_POSTGRES_USER} ${PRODUCTION_POSTGRES_DATABASE} < /tmp/${PRODUCTION_POSTGRES_ARTEFACT_NAME}' > /dev/null
    "


  - # On production save current deployment settings to file.
  - # Variables are inversed and shifted

  - >
    run_on_production "
      echo \"NGINX_PORT_SET_CURRENT=${PRODUCTION_NGINX_PORT_SET_PREVIOUS}\" > ${PRODUCTION_ENVIRONMENT_FILE}
      echo \"NGINX_PORT_SET_PREVIOUS=${PRODUCTION_NGINX_PORT_SET_CURRENT}\" >> ${PRODUCTION_ENVIRONMENT_FILE}
      echo \"COMMIT_CURRENT=${COMMIT}\" >> ${PRODUCTION_ENVIRONMENT_FILE}
      echo \"COMMIT_PREVIOUS=${PRODUCTION_COMMIT_CURRENT}\" >> ${PRODUCTION_ENVIRONMENT_FILE}
    "


  - # On production forward 80 and 443 ports to the fresh deployment ports

  - >
    run_on_production "
      sudo bash /root/scripts/remove_port_forwarding.sh
      sudo bash /root/scripts/forward_ports_${PRODUCTION_NGINX_PORT_SET_PREVIOUS}.sh
    "


  - # Stop current production containers on production.
  - # Requests will start hitting fresh installation

  - >
    if [ -n "${PRODUCTION_COMMIT_CURRENT}" ]; then
      run_on_production "
        docker stop ${PROJECT_NAME}${PRODUCTION_COMMIT_CURRENT}_nginx_1 \
                    ${PROJECT_NAME}${PRODUCTION_COMMIT_CURRENT}_django_1 \
                    ${PROJECT_NAME}${PRODUCTION_COMMIT_CURRENT}_postgres_1
      "
    else
      echo 'No current commit'
    fi


  - # Remove previous production containers

  - >
    if [ -n "${PRODUCTION_COMMIT_PREVIOUS}" ]; then
      run_on_production "
        previous_nginx_image=`docker ps -a | grep "${PROJECT_NAME}${PRODUCTION_COMMIT_PREVIOUS}_nginx_1" | awk '{print $2}'`
        previous_django_image=`docker ps -a | grep "${PROJECT_NAME}${PRODUCTION_COMMIT_PREVIOUS}_django_1" | awk '{print $2}'`
        previous_postgres_image=`docker ps -a | grep "${PROJECT_NAME}${PRODUCTION_COMMIT_PREVIOUS}_postgres_1" | awk '{print $2}'`

        echo '##########'
        echo ${previous_nginx_image}
        echo ${previous_django_image}
        echo ${previous_postgres_image}

        docker rm ${PROJECT_NAME}${PRODUCTION_COMMIT_PREVIOUS}_nginx_1 \
                  ${PROJECT_NAME}${PRODUCTION_COMMIT_PREVIOUS}_django_1 \
                  ${PROJECT_NAME}${PRODUCTION_COMMIT_PREVIOUS}_postgres_1

        docker rmi ${previous_nginx_image} \
                   ${previous_django_image} \
                   ${previous_postgres_image}
      "
    else
      echo 'No container and image rotation because previous commit is unknown'
    fi


  - # Rotate things on production

  - >
    run_on_production "
      DIRECTORIES='
        ${PRODUCTION_ARTEFACTS_STATIC_DIRECTORY}
        ${PRODUCTION_ARTEFACTS_POSTGRES_DIRECTORY}
        ${PRODUCTION_BACKUPS_POSTGRES_DIRECTORY}
        ${PRODUCTION_IMAGES_NGINX_DIRECTORY}
        ${PRODUCTION_IMAGES_DJANGO_DIRECTORY}
        ${PRODUCTION_IMAGES_POSTGRES_DIRECTORY}
        ${PRODUCTION_REPOSITORIES_DIRECTORY}
      '
      for directory in \${DIRECTORIES}
      do
        cd ${directory};
        echo "directory: ${directory}";
        echo 'current working directory:' `pwd`;
        # ls -1tr | head -n -10 | xargs -d '\n' rm -f --;
      done
    "
